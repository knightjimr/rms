
Getting Started - Hello World!
==============================

The RMS software has been packaged with three executable scripts, hello1, hello2 and hello3.  Running these
scripts will test your access to the software, and its ability to run across your cluster.  The source code
for the scripts are shown below, so it also gives several examples of simple RMS scripts.

The first script to run is hello1, which tests your access to RMS.  The example here just uses "a b c d" as
the arguments on the command-line, but the script can take any text as arguments.  When you run hello1, the
results should appear similar to this (where text in bold is the command-line, and "$" is the command-line
prompt): ::

   :emphasis:`$ hello1 a b c d`
   Hello a!
   Hello b!
   Hello c!
   Hello d!
   Said hello to all of the arguments!

The hello1 script just runs on the current computer, not across the cluster.  The second script, hello2,
generates equivalent output, but it executes across the cluster.  Running it should generate the following
output: ::

   **$ hello2 a b c d**
   Hello a, from the cluster!
   Hello b, from the cluster!
   Hello c, from the cluster!
   Hello d, from the cluster!
   Said hello to all of the arguments from the cluster!

Be aware that this script will run slower (possibly much slower) than hello1.  The reason is that RMS
queues a job for a compute node on the cluster, then sends the commands to the RMS program
running on that node for execution.  So, the time it takes to generate the output will depend on how
long it takes to allocate a compute node and then communicate the execution of those commands.  To get
a gauge of how long that might be, start up an interactive job on the cluster, and time how long it
takes to get the command prompt.

If hello2 takes much longer than that to execute, use qstat (or your clusters' equivalent) to determine
if there is a compute job queued or running.  RMS names its jobs "worker1", "worker2", ... for each 
compute node it allocates.  If the job is still queued, then RMS is waiting for the cluster to run
the remote worker program. If there is no job queued or running, run "cat RMS_hello2_*/worker1.pbs.err"
to see if the RMS worker reported an error before it was able to contact the head RMS process.

If you get an error message from hello2, that is a signal that the cluster configuration is not right,
and you'll need to configure access to the cluster properly, so that RMS can run jobs on the cluster.

The third script, hello3, does the same computation across the cluster as hello2, but displays the output
in the form that you will typically see when you run RMS with your own scripts.  Running hello3 should
display output similar to the following (where the lines similar to those in italics should appear on
the screen as the scripts are run across the cluster, as progress messages about the computation): ::

   **$ hello3 a b c d**
   Sheet Input:  4 rows, 1 columns.
   Commands:  5 commands to be executed.
   [Tue Jan 19, 4:22pm]:Pipeline execution starting.
   [Tue Jan 19, 4:22pm]:     goodbye[1]: 0q,1r,0f,0c
   [Tue Jan 19, 4:22pm]:Pipeline execution completed.

In this output, 'q' stands for queued, 'r' stands for running, 'f' stands for failed and 'c' stands
for completed, the names 'hello' and 'goodbye' are the names of the steps of the rms script, and the number
in brackets is the number of scripts that are to be executed for each step.  Also, only the steps that
have scripts that are queued or running are displayed.  For longer running scripts, this progress
information gives a real-time view of how the computation is executing across the cluster, and whether
it has made any progress recently.

Whenever rms is executed in this mode (and this is the default execution mode), rms writes two files,
in this case RMS_hello3_YYMMDD_HHMMSS.stdout and RME_hello3_YYMMDD_HHMMSS.stderr (where "YYMMDD" and
"HHMMSS" are the date and time when the script was started).  They contain the ordered standard output
and standard error text from the scripts, output in the order the commands would be run if they were
executed sequentially, regardless of the order they were actually executed across the cluster. So, if
you run "cat RMS_hello3_*.stdout", you will see the same output as was generated by running hello2.
